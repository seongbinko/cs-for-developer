# 테이블과 인덱스의 차이
테이블은 데이터가 정렬되어 있지 않고 입력된 순서대로 들어있다.
인덱스는 데이터가 정렬되어 있다.

# 인덱스 사용 이유
인덱스는 조회에서 성능향상을, 삽입, 변경, 삭제에서 성능저하.
-> 기존 데이터 뿐만 아니라 인덱스데이터도 삽입, 변경, 삭제해 주어야 하기 때문.
-> b-tree의 경우 b-tree 구조 조건을 유지하기 위해 삽입, 변경, 삭제 시 tree를 재구성하는 일이 벌어지게 되고, 이럴 경우 부하가 커질 수 있음.
->변경시에는 기존데이터를 삭제 + 새로운 데이터 삽입 두가지 과정이 일어남
->삭제 시에는 기존 데이터를 삭제하는 것이 아닌 사용안함 표시를 하고 새로운 데이터를 삽입한다.(테이블데이터는 삭제 후 삽입한다.)
->이 경우 인덱스데이터에는 삭제되지 않은 데이터가 쌓이게 되고, 갱신작업이 계속 될수록
실제 데이터갯수와 인덱스 데이터갯수가 크게 불일치 하는 현상이 발생할 수 있다. 이럴 경우 인덱스를 사용하는 것이 오히려 성능이 떨어질 수 있다.
-> 주기적으로 인덱스를 재구성하는 이유이다.

# 인덱스 단점
인덱스라는 데이터를 디스크에 저장해야 하기 때문에 메모리 사용량이 늘어난다.
인덱싱된 컬럼에서 데이터 갱신작업이 일어날 때 성능 저하
갱신작업이 많이 일어나게 되면 인덱스와 실제데이터에 차이가 크게 발생할 수 있고,
이를 없애기 위해 인덱스를 재구성해주어야 하는 일이 발생

# 인덱스 자료구조 (b-tree)
B-TREE 인덱스는 말 그대로 B-TREE라는 자료구조에 기반하여 생성된 인덱스이다.

먼저, 인덱스의 자료구조로서 B-TREE의 가장 중요한점을 말하자면
어떠한 상황에서도 데이터 조회 시 O(logN)을 보장한다는 점이다

일반적인 tree 자료구조의 경우 데이터가 한쪽으로 치우치게 되면
linkedlist처럼 동작하여 수행시간이 최악의 경우 O(N)이 될 수 있다.

B-TREE가 이런 성능을 제공할 수 있는 이유는 
B-TREE의 구조에 제약조건이 있기 때문이다.

## B-TREE의 조건
1. 노드의 데이터가 n개라면 자식노드의 개수는 n+1개
-> b-tree는 한 노드에 여러개의 데이터를 담을 수 있다.
-> 이는 ‘차수’ 라는 수치와도 연결되는데,  어떤 b-tree의 차수가
k라고 한다면, 이 b-tree의 모든 노드들은 최대 k-1개의 데이터를 담을 수 있고,
root와 leaf노드를 제외한 모든 노드들은 적어도 [k/2] 개의 자식노드를 가지고 있어야 한다.
( [ ] 는 floor 연산)
2. 노드의 데이터는 정렬된 상태
3. 데이터 중복 불가
4. 모든 leaf는 동일한 높이를 가져야 한다.



# b-tree 구조가 다른 자료구조보다 효율적인 이유

탐색시간이 O(logN) 이하인 다른 자료구조들도 많은데, 왜 b-tree를 택했을까
1. 해시테이블
데이터 하나를 찾는 것은 O(1)이지만 부등호 연산처럼 특정 기준보다 작거나
큰 것을 찾게 될 경우, 해시테이블은 정렬되어있지 않기, 모든 값을 다 탐색해야 한다.
2. 레드블랙트리
b-tree와 유사하지만, 가장큰 차이점은 한 노드에 담을 수 있는 데이터 수이다.
b-tree는 한 노드에 여러데이터를 담을 수 있고 이는 디스크의 연속된 메모리에 담겨져 있다.
따라서 데이터 탐색에서 b-tree가 더 우수한 성능을 갖는다.


# b-tree의 삽입, 삭제
1. 삽입(홀수차수)
초기데이터는 root 구성
그 이후로는 맞는 위치를 찾아가서 데이터를 넣을것인데,
만일 해당 노드가 이미 꽉 찼을 경우에는 중간값을 기준으로 분리한다.
만일 분리 했을 때, b-tree 조건에 부합하지 않으면
부모노드로 올라가면서 merge 하는 과정을 반복한다.
1-1) 삽입(짝수차수)
홀수차수랑 같은데 차이점은 데이터 분할 시 중간값이 아니라
중간값에서 왼쪽값을 사용한다.

2. 삭제
leaf일 경우와 leaf가 아닐 경우로 나뉜다.
2-1) leaf일 경우 삭제
leaf를 삭제하게 되었을 때 만일 b-tree 조건에 부합하지 않는다면
부모노드에서 자신보다 작은 값중 가장 큰값을 가져와 형제노드와 merge한다.
만일 자신보다 작은값이 없다면, 자신보다 크면서 가장 작은 값을 가져온다.
2-2)non-leaf일 경우
non-leaf일 경우 삭제 시 무조건 b-tree 조건이 어긋나게 된다.
삭제 후 자신의 자식값들 중 가장 큰 값을 가져온다.
만일, 자식노드에 불균형이 생기면 여기서부터 leaf 삭제과정과 동일하게
균형을 맞춰나간다.
https://www.cs.usfca.edu/~galles/visualization/BTree.html

# 인덱스의 활용

인덱스를 생성할 컬럼을 고를 시 카디널리티가 높은 순서로 고른다.(중복도가 낮은 순으로 고른다)
단일인덱스 여러개보다 다중컬럼 인덱스를 고려한다.
-> 선택도가 좋지 못한 컬럼 여러개를 묶어 사용하는 방법
-> where 조건에서 동시에 사용되는 컬럼
조회 쿼리에 where, join 예약어를 사용했을 때만 인덱스가 사용된다.
조회를 많이하고, 삽입, 변경, 삭제는 적게 하는 컬럼에 사용하는 것이 좋다.
조회보다 갱신작업이 더 빈번히 일어나는 컬럼은 인덱스가 비효율적이다.
where, join 조건절에 자주 사용되는 컬럼에 대해 인덱스를 생성하는 것이 좋다.

where, join 조건절에서 컬럼조건 작성 시
카디널리티가 높을수록(중복도가 낮을수록) 먼저 작성한다.


무조건 인덱스 범위스캔성능이 풀스캔성능보다 좋다고 단정 지을 수 없다.
선택도 = 서로다른 값의 row수 * 100 / 전체 row 수
보통 5~10%의 선택도를 가지면 인덱스 스캔이 우수하다고 한다.

## 인덱스가 동작하지 않는 조건
1. 인덱스 컬럼절을 변경해서 사용하는 경우
-> EMPNO 컬럼으로 인덱스가 생성되었을 경우에 
WHERE EMPNO + 5 > 10 은 인덱스를 타지 않는다.
2. 내부적인 데이터 변환
테이블 생성시 EMPNO 컬럼을 ‘숫자형’으로 생성하였고
이 EMPNO컬럼에 대해 인덱스를 생성해놓았을 때,
WHERE EMPNO = ‘10’ 으로 문자형으로 조회하게 되면
내부적으로 문자형 -> 숫자형 데이터변환이 일어나게 되는데
이런 경우에 인덱스가 동작하지 않는다.
3.NULL 조건 사용
인덱스 데이터에는 NULL이 없다.
WHERE NAME IS NULL 은 인덱스가 동작하지 않는다.
4. 부정형 조건의 사용 
WHERE EMPNO != 10 은 인덱스가 동작하지 않는다.
WHERE EMPNO > 10 OR EMPNO < 10 로 대체.
5. LIKE 연산자에서 %가 앞에 올 경우
WHERE NAME LIKE ‘%JO%’ 일 경우 인덱스가 동작하지 않는다.
WHERE NAME LIKE ‘JO%’로 대체. 

## 인덱스 키 크기와 성능
b-tree 인덱스의 경우 인덱스의 키는 가능한 작게 설계한다.
-> B-tree 인덱스는 key, value 쌍으로 이루어져있다.
-> key는 인덱스를 생성한 컬럼값, value는 해당 row의 디스크주소 혹은 해당 row가 담겨있는 페이지의 디스크주소(RID 혹은 ROW ID 라고 함)
-> 이 key, value쌍이 여러개 담겨 있는 것을 페이지라고 한다.
->페이지 크기에는 제한이 있기 때문에, key의 크기가 커지면 그만큼 한 페이지에 담을 수 있는 key, value 쌍의 개수가 적어진다.
-> 그렇게 되면 원하는 데이터를 찾기 위해 더 많은 디스크 I/O가 필요해 지고 이는 성능 악화로 이어진다.

# 인덱스 동작 과정
SELECT * FROM CUSTOMER WHERE ID = 10; 쿼리를 수행할 때
1. SQL 파싱 과정을 마친 후 DB BUFFER CACHE에 ID=10인 데이터가 있는지 확인
2. 있다면 데이터 반환
3. 없다면, 이때 해당 컬럼에 대해 인덱스가 있을 경우
3-1) 인덱스를 통해 ID=10인 데이터의 RID를 조사.
3-2) 그 해당 RID를 통해 디스크에 접근하여 데이터를 읽어서 DB BUFFER CACHE에 옮김
3-3) 그 후 DB BUFFER CACHE에서 원하는 데이터를 찾아서 반환
4. ID=10인 데이터가 CACHE에 없고 인덱스도 없을 경우
4-1) ID=10인 데이터가 디스크 어느위치에 있는지 모르므로 일일이 찾는다.
4-2) 모든 데이터 블록에 접근하여 이를 DB BUFFER CACHE에 옮기고,
옮긴 데이터에서 다시 원하는 데이터를 찾는 과정을 반복한다.



# 참고한 자료들
https://www.vertabelo.com/blog/all-about-indexes-part-2-mysql-index-structure-and-performance/

https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC

https://www.geeksforgeeks.org/introduction-of-b-tree-2/

https://jojoldu.tistory.com/243

https://lalwr.blogspot.com/2016/02/db-index.html

https://matice.tistory.com/8
